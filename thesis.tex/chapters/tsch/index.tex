\chapter{Time-Slotted Channel Hopping Implementation for LoRa\label{section:tsch}}

This chapter will cover the adaptation of the TSCH MAC protocol in Contiki OS to
work with LoRa.
It cover the issues induced by the current Contiki implementation and how I
managed to fix them to achieve a Time-Slotted Channel Hopping working with LoRa.

The reader of this chapter will get a better understanding of the the steps
required to port TSCH to a new LoRa module.

\section{Timing parameters}

Contiki developers have already implemented the parameters for
platforms using IEEE 802.15.4.
Adapting the timing to LoRa would mean longer time period because of the long
transmission time on LoRa, which lead to a set of problems that we will cover in this
section.

Contiki use the following parameter we need to define in $\mu s$ to time each
part of a time slot.

% Guard time precise = better energy usage.

\begin{lstlisting}
enum tsch_timeslot_timing_elements {
  tsch_ts_cca_offset,
  tsch_ts_cca,
  tsch_ts_tx_offset,
  tsch_ts_rx_offset,
  tsch_ts_rx_ack_delay,
  tsch_ts_tx_ack_delay,
  tsch_ts_rx_wait,
  tsch_ts_ack_wait,
  tsch_ts_rx_tx,
  tsch_ts_max_ack,
  tsch_ts_max_tx,
  tsch_ts_timeslot_length,
  tsch_ts_elements_count, /* Not a timing element */
};
\end{lstlisting}

I did not define \lstinline{tsch_ts_cca_offset} and \lstinline{tsch_ts_cca} 
because \emph{CCA} is implossible with LoRa.
Also, \lstinline{tsch_ts_rx_tx} is not used anywhere in the Contiki codebase.

\begin{itemize}
  \item \lstinline{tx_offset} represents the time needed for the packet to get
    prepared before getting transmitted on air. The end of
    \lstinline{tx_offset} s the moment the packet get transmitted. 
    The parameter is the same as \lstinline{rx_offset}.
  \item \lstinline{max_tx} is the maximum transmission time (time on air) using
    LoRa. The parameter depends on the spreading factor and the maximum number
    of bytes transmittable.
  \item \lstinline{rx_ack_delay} buffering time between packet transmission and
    the acknowledgement reception. This delay is long enough for the receiver
    to receive the message compute its check for correctness and transmit the acknowledgement packet.
    The parameter is the same as \lstinline{tx_ack_delay}.
  \item \lstinline{ts_max_ack} is the maximum transmission time (time on air) for
    the acknowledgement packet reception.
\end{itemize}

Figure~\ref{fig:tstiming} represents the parameters organization during
a time-slot.

\input{thesis.tex/chapters/tsch/fig/timeslots.tex}

\subsection{Timing size issue}

Contiki stored each timing parameter in a 16 bit unsigned integer.

\begin{lstlisting}
typedef uint16_t tsch_timeslot_timing_usec[tsch_ts_elements_count];
\end{lstlisting}

This set the maximum parameter value to $64436\mu s$.
This value is not long enough to store LoRa transmissions at maximum payload.
It take 379 ms to transmit a maximum payload packet with the fastest spreading
factor (SF 7).

I changed the TSCH implementation to use 32 bit integer instead, allowing more
room for the parameters.

\begin{lstlisting}
typedef uint32_t tsch_timeslot_timing_usec[tsch_ts_elements_count];
\end{lstlisting}

\subsection{$\mu s$ and $rtimer$ ticks conversion}

Contiki makes all microsecond to \emph{RTIMER} conversion with the following
function.

\begin{lstlisting}
#define US_TO_RTIMERTICKS(US)  ((US) >= 0 ?                        \
  (((int32_t)(US) * (RTIMER_ARCH_SECOND) + 500000) / 1000000L) :      \
  ((int32_t)(US) * (RTIMER_ARCH_SECOND) - 500000) / 1000000L)
\end{lstlisting}

The 32 bits signed integer has a maximum value of \ref{eq:maxint32}.

\begin{equation}
  \label{eq:maxint32}
  max(int32\_t) = \frac{2^{32}}{2} - 1 = 2147483647
\end{equation}

Using the CC2538 second definition and I can calculate the maximum time in $\mu s$
I can pass to the macro before overflowing.

\begin{equation}
  \label{eq:maxus}
  \begin{multlined}
  RTIMER\_ARCH\_SECOND = 32768 \\
  max(int32\_t) = x * RTIMER\_ARCH\_SECOND + 500000 \\
  x = ceil(\frac{max(int32\_t) - 500000}{RTIMER\_ARCH\_SECOND}) \\
  x = 131057 \\
  \end{multlined}
\end{equation}

Every conversion over 131056 $\mu s$ will make the 32 bits integer overflow.
I made a new conversion function using 64 bits integer instead to avoid the
limitation and changed every conversion made with the previous version in TSCH
with this new one.

\begin{lstlisting}
#define US_TO_RTIMERTICKS_64(US) ((US) >= 0 ? \
  ((int32_t)(((int64_t)(US) * (RTIMER_ARCH_SECOND) + 500000) / 1000000L)) : \
  ((int32_t)((int64_t)(US) * (RTIMER_ARCH_SECOND) - 500000) / 1000000L)) 
\end{lstlisting}

\subsection{Interrupt Priority Clash}

Each time-slot operation is scheduled using \lstinline{rtimer_set}.
This function schedules the time-slot using the real-time timer from the CC2538.
It means that the time-slot is ran in an interrupt.

This is not an issue in the original implementation of TSCH using the CC2536
because the radio driver is internal to the processor.
The radio driver needs to also use interrupts to receive messages from the UART.
By default the real-time timer, \lstinline{SMT_IRQn}, has the same priority as
the UART1 interruption. 
This is why I changed the \lstinline{rtimer_arch_schedule} implementation with
the following line to set a lower priority.

\begin{lstlisting}
NVIC_SetPriority(SMT_IRQn, 7); 
\end{lstlisting}

\subsection{Watchdog}

The CC2538 watchdog is set to a period of 32,768 ticks or 1 second. 
Because Contiki run most TSCH operations inside an interrupt
context, the watchdog timer is not reset inside.
During long wait or long transmissions, the watchdog is not reset and would
make the system reset.
This is why when the program busywait with the command
\lstinline{RTIMER_BUSYWAIT_UNTIL_ABS}, I modified it execution to also execute
a \lstinline{watchdog_periodic} to reset the watchdog timer.

\subsection{Drift limitations}

\subsection{Guard time issue}

\section{Porting TSCH}

According to the \emph{contiki-ng}
wiki\footnote{\url{https://github.com/contiki-ng/contiki-ng/wiki/Documentation:-TSCH-and-6TiSCH}}
on TSCH, porting the MAC protocol to new radio platforms, requires specific
configurations parameters.

The radio driver defines those PHY layer specific parameters.

\subsection{Channels}

% Channel hopping is one of the main feature of TSCH. 

\subsection{Packet Duration}

LoRa Transmission duration is known with the equation
in \ref{eq:tpacket}.

The current implementation of Contiki calculate the time on air with the
\lstinline{TSCH\_PACKET\_DURATION(bytes)} macro by using two parameters to do the
calculation.

\begin{itemize}
    \item RADIO\_BYTE\_AIR\_TIME
    \item RADIO\_PHY\_OVERHEAD
\end{itemize}

Because LoRa communication is dependant on the number of symbols transmitted
instead of the number of bytes the current implementation in TSCH is not
precise enough.

I changed the TSCH implementation to allow user defined macro and
I replaced it by the equation~\ref{eq:tpacket} for precise measurement
of the time on air.

\subsection{Radio delay}

Radio delays are hardware platform dependent values. 
They get accessed from the radio driver.

TSCH use three of these values.

\begin{itemize}
  \item RADIO\_CONST\_DELAY\_BEFORE\_TX
  \item RADIO\_CONST\_DELAY\_BEFORE\_RX
  \item RADIO\_CONST\_DELAY\_BEFORE\_DETECT
\end{itemize}

They should in theory be constant but since the communication delay depends
on the transmission length with the RN2483 module, I made them variable.

% TODO oscilloscope output picture

\subsubsection{Transmission delay}

Represents the time for the module to get messages on air. 
This delay is made of 3 parts.

\begin{enumerate}
  \item UART message transmission to the module.
  \item Module message treatment (time between the end of $1.$ and the start of $3.$).
  \item Module sending back acknowledgement.
\end{enumerate}

The program knows the message length because
\lstinline{NETSTACK_RADIO.prepare()} is executed before getting this parameter.
The acknowledgement length is constant. 
I can then calculate parameter $1.$ and $3.$ with the equation~\ref{eq:baudrate}.

\begin{equation}
  \label{eq:baudrate}
  UART(x) = \frac{x . (bit_{start} + bits_{data} + bit_{stop})}{baudrate}
\end{equation}

The second parameter is unknown and the datasheet does not give any meaningful
information about the module that computates the timing.

I did measurement of the time between message transmission and acknowledgement
with an oscilloscope to try to find a correlation between the number of bytes
transmitted and the treatment length.

\begin{figure}[H]
  \centering

  \begin{tikzpicture}
  \begin{axis}[
    width=0.8\textwidth,
    height=0.6\textwidth,
    axis x line=bottom,
    xmin=3000,
    xmax=24000,
    xlabel={$time_{\mu s}$},
    xlabel near ticks,
    xticklabel style={/pgf/number format/1000 sep=},
    axis y line=left,
    ymin=0,
    ymax=128,
    ylabel={bytes},
    ylabel near ticks
  ]
    \addplot[color=red,mark=x] coordinates {
      (3080,1)
      (3560,4)
      (4200,8)
      (6400,21)
      (8280,32)
      (12600,58)
      (13680,64)
      (17360,86)
      (23800,124)
    };
  \end{axis}
  \end{tikzpicture}

  \caption{Message treatment delay measurements\label{fig:transmissiondelay}}
\end{figure}

There is a clear linear relation between the number of bytes transmitted and
the message treatment time.
Based on these measurements the best matching function is the following.

\begin{equation}
  \label{eq:transmissioncompute}
  T_{TX}(x) = 2852 + 169x \ \ \ \ (\mu s)
\end{equation}

The parameter returns the total transmission delay with the following
the~equation~\ref{eq:transmissiondelay}.

\begin{gather}
  \label{eq:transmissiondelay}
  msg_{length}(x) = x * 2 + length("radio~tx~\backslash r \backslash n") \\
  Delay_{TX}(x) = T_{TX}(x) + UART(msg_{length}(x)) + UART(length("ok \backslash r\backslash n"))
\end{gather}

The spreading factor does not influence the transmission delay.

The precision of this parameter is essential for synchronized communication
with TSCH. It will indicate to TSCH how to conduct its radio transmission
precisely at the end of \lstinline{TS_TX_OFFSET}.

\subsubsection{Reception delay}

This parameter is hard to really measure with the RN2483.

\begin{enumerate}
  \item Waking up the radio.
  \item Start listening to incoming messages.
\end{enumerate}

\subsubsection{Detection delay}

% TODO Detection does not really represent that. It the delay between the start
% of the transmission and the acknowledgement by the platform since we can't
% really know when the communication start this value will be used out of
% context.
% Because RN2483 miss a way to detect transmission we are using variable in
% TSCH the wrong way.

Represent the time for the module to transmit new messages to the platform
from the moment the communication is finished.
This delay is made of two parts we can calculate when we know the message
length.

\begin{enumerate}
  \item Module message computation
  \item UART message transmission from the module to the platform
\end{enumerate}

I also measured the delay between the end of communication and the start of the
message transmission to the platform with an oscilloscope.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
  \begin{axis}[
    width=0.8\textwidth,
    height=0.6\textwidth,
    axis x line=bottom,
    xmin=0,
    xmax=55000,
    xlabel={$time_{\mu s}$},
    xlabel near ticks,
    xticklabel style={/pgf/number format/1000 sep=},
    axis y line=left,
    ymin=0,
    ymax=128,
    ylabel={bytes},
    ylabel near ticks
  ]
    \addplot[color=red,mark=x] coordinates {
      (820,1)
      (1420,4)
      (1940,3)
      (2350,4)
      (4240,8)
      (8160,16)
      (15600,32)
      (31100,64)
      (53200,110)
    };
  \end{axis}
  \end{tikzpicture}
  \caption{Reception delay measurements\label{fig:transmissiondelay}}
\end{figure}

The best matching function I found, used the number of symbols transmitted as
parameter.

\begin{equation}
  \label{eq:detectcomp}
  T_{detect}(x) = 408x + 49 . N_{sym}(x) \ \ \ (\mu s)
\end{equation}

The total detection delay is calculated with the following formula.

\begin{gather}
  msg_{length}(x) = x * 2 + length("radio~rx~~\backslash r \backslash n") \\
  \label{eq:detectdelay}
  Delay_{detect}(x) = T_{detect}(x) + UART(msg_{length}(x))
\end{gather}

\subsection{Packet Timestamp}

Timestamps are an essential variable in TSCH to calculate timeslot drift
between two motes. 
Contiki takes the packet timestamps at the moment the transmission starts.
There is no way with the RN2483 module to know when the reception started.
On packet reception, I calculate the timestamp with the detect delay 
in equation~\ref{eq:detectdelay} and the transmission time in
equation~\ref{eq:tpacket}.

Each timeslot uses the same offset before starting the actual transmission.
Knowing the packet timestamp precisely allows the receiving mote to determine the
drift from the transmitter. Some motes are designed as time source and
receiving mote will adjust their clock to these.

\subsection{Mitigating the drift}

The transmitter can know in advance the moment the receiver will fully
receive the message. In the previous implementation of TSCH the transmitter
slot operation used to wait a constant time between transmissions. I modified
this to include the detection delay at the transmitter side and the receiver
will wait a constant time at reception instead.

This will mitigate the effect of drifting timeslots, big messages are increasing
the detection time that could lead to miss the time frame for sending the
acknowledgement.

\section{Testing}

\subsection{simple-node}

\subsection{UDP Transmission}

\input{thesis.tex/chapters/tsch/fig/schedule.tex}

\section{Energy consumption}

\section{Considerations}

\chapter{Time-Slotted Channel Hopping Implementation for LoRa\label{section:tsch}}

This chapter will cover the adaptation of the TSCH MAC protocol in Contiki OS to
work with LoRa.
It covers the issues induced by the current Contiki implementation and how I
managed to fix them to achieve Time-Slotted Channel Hopping working with LoRa.

The reader of this chapter will get a better understanding of the steps
required to port TSCH to a new LoRa module in Contiki.

\section{Timing parameters\label{section:timingparameters}}

Contiki developers have already implemented the parameters for
platforms using IEEE 802.15.4.
Adapting the timing to LoRa would mean longer time slots because of the long
transmission duration of LoRa.
This leads to a set of problems that we will cover in this
section.

Contiki uses the following parameter we need to define in $\mu s$ to time each
part of a time slot.

% Guard time precise = better energy usage.

\begin{lstlisting}
enum tsch_timeslot_timing_elements {
  tsch_ts_cca_offset,
  tsch_ts_cca,
  tsch_ts_tx_offset,
  tsch_ts_rx_offset,
  tsch_ts_rx_ack_delay,
  tsch_ts_tx_ack_delay,
  tsch_ts_rx_wait,
  tsch_ts_ack_wait,
  tsch_ts_rx_tx,
  tsch_ts_max_ack,
  tsch_ts_max_tx,
  tsch_ts_timeslot_length,
  tsch_ts_elements_count, /* Not a timing element */
};
\end{lstlisting}

I did not define \lstinline{tsch_ts_cca_offset} and \lstinline{tsch_ts_cca} 
because \emph{CCA} is impossible with LoRa.
Also, the parameter \lstinline{tsch_ts_rx_tx} is not used anywhere in the 
Contiki codebase.

\begin{itemize}
  \item \lstinline{tx_offset} represents the time needed for the packet to get
    prepared before getting transmitted on air. The end of
    \lstinline{tx_offset} is the moment the packet gets transmitted. 
    The parameter is the same as \lstinline{rx_offset}.
    As we saw in~Fig~\ref{fig:sync} the bigger this parameter the bigger the
    clock drift can be between two nodes.
  \item \lstinline{max_tx} is the maximum transmission time (time-on-air) using
    LoRa. The parameter depends on the spreading factor and the maximum number
    of bytes transmittable.
  \item \lstinline{rx_ack_delay} buffering time between packet transmission and
    the acknowledgement reception. This delay is long enough for the receiver
    to receive the message computes its check for correctness and transmits the acknowledgement packet.
    The parameter is the same as \lstinline{tx_ack_delay}.
  \item \lstinline{ts_max_ack} is the maximum transmission time (time on air) for
    the acknowledgement packet reception.
\end{itemize}

Figure~\ref{fig:tstiming} represents the organization of the parameters during
a time slot.

\input{thesis.tex/chapters/tsch/fig/timeslots.tex}

\subsection{Timing size issue}

Contiki stored each timing parameter in a 16-bit unsigned integer.

\begin{lstlisting}
typedef uint16_t tsch_timeslot_timing_usec[tsch_ts_elements_count];
\end{lstlisting}

This sets the maximum parameter value to $64436\mu s$.
This value is not long enough to store LoRa transmissions at maximum payload.
It takes 379 ms to transmit a maximum payload packet with the fastest spreading
factor (SF 7).

I changed the TSCH implementation to use 32-bit integer instead, allowing more
room for the parameters.

\begin{lstlisting}
typedef uint32_t tsch_timeslot_timing_usec[tsch_ts_elements_count];
\end{lstlisting}

\subsection{$\mu s$ and $rtimer$ ticks conversion}

Contiki makes all microsecond to \emph{RTIMER} conversion with the following
function.

\begin{lstlisting}
#define US_TO_RTIMERTICKS(US)  ((US) >= 0 ? \
 (((int32_t)(US)*(RTIMER_ARCH_SECOND) + 500000) / 1000000L) : \
 ((int32_t)(US)*(RTIMER_ARCH_SECOND) - 500000) / 1000000L)
\end{lstlisting}

The 32 bits signed integer has a maximum value of \ref{eq:maxint32}.

\begin{equation}
  \label{eq:maxint32}
  max(int32\_t) = \frac{2^{32}}{2} - 1 = 2147483647
\end{equation}

Using the CC2538 second definition and I can calculate the maximum time in $\mu s$
I can pass to the macro before overflowing.

\begin{equation}
  \label{eq:maxus}
  \begin{multlined}
  RTIMER\_ARCH\_SECOND = 32768 \\
  max(int32\_t) = x * RTIMER\_ARCH\_SECOND + 500000 \\
  x = ceil(\frac{max(int32\_t) - 500000}{RTIMER\_ARCH\_SECOND}) \\
  x = 131057 \\
  \end{multlined}
\end{equation}

Every conversion over 131056 $\mu s$ will make the 32 bits integer overflow.
I made a new conversion function using 64 bits integer instead to avoid the
limitation and changed every conversion made with the previous version in TSCH
with this new one.

\begin{lstlisting}
#define US_TO_RTIMERTICKS_64(US) ((US) >= 0 ? \
 ((int32_t)(((int64_t)(US)*(RTIMER_ARCH_SECOND)+500000)/1000000L)) : \
 ((int32_t)((int64_t)(US)*(RTIMER_ARCH_SECOND)-500000)/1000000L)) 
\end{lstlisting}

\subsection{Interrupt Priority Clash}

Each time slot operation is scheduled using \lstinline{rtimer_set}.
This function schedules the time slot using the real-time timer from the CC2538.
It means that the time slot is run in an interrupt.

This is not an issue in the initial implementation of TSCH, which use the
CC2536, because the radio driver is internal to the processor.
The radio driver needs to also use interrupts to receive messages from the UART.
By default the real-time timer, \lstinline{SMT_IRQn}, has the same priority as
the UART1 interruption. 
This is why I changed the \lstinline{rtimer_arch_schedule} implementation with
the following line to set a lower priority.

\begin{lstlisting}
NVIC_SetPriority(SMT_IRQn, 7); 
\end{lstlisting}

\subsection{Watchdog}

The CC2538 watchdog is set to a period of 32,768 ticks or 1 second. 
Because Contiki runs most TSCH operations inside an interrupt
context, the watchdog timer is not reset inside.
During long waits or long transmissions, the watchdog is not reset and trigger
a system reset.
This is why when the program busy waits with the command
\lstinline{RTIMER_BUSYWAIT_UNTIL_ABS}, I modified its execution to also execute
a \lstinline{watchdog_periodic} to reset the watchdog timer.

\subsection{Drift correction limitations}

During the acknowledgement frame, the receiver can transmit his drift from the
transmitter in $\mu s$. 
We must take into account this value is limited to a range of $-2047$ to
$2047$ because of the structure of the packet.

Bigger drift can occur in my implementation. 
I have to take into account this limitation to prevent overflows.

\section{Porting TSCH}

According to the \emph{contiki-ng}
wiki\footnote{\url{https://github.com/contiki-ng/contiki-ng/wiki/Documentation:-TSCH-and-6TiSCH}}
on TSCH, porting the MAC protocol to new radio platforms requires specific
configurations parameters.

The radio driver defines PHY layer specific parameters.

\subsection{Channels}

Channel hopping is one of the main features of TSCH that needs to be implemented
at the driver level.
For my experimentation, I only implemented three channels that can be selected
with the \lstinline{RADIO_PARAM_CHANNEL} argument.
I used the three following channels but the other channels available in LoRaWAN
could also be implemented.

\begin{itemize}
  \item 868.1 MHz, 125 kHz BW
  \item 868.3 MHz, 125 kHz BW
  \item 868.5 MHz, 125 kHz BW
\end{itemize}

Three different channels also reduce the time for a node to join the network,
making the testing faster.

\subsection{Packet Duration\label{section:transmissiontime}}

LoRa Transmission duration is known with the equation in \ref{eq:tpacket}.
The current implementation of Contiki calculates the time-on-air with the
\lstinline{TSCH_PACKET_DURATION(bytes)} macro by using two parameters to do the
calculation.

\begin{itemize}
  \item RADIO\_BYTE\_AIR\_TIME
  \item RADIO\_PHY\_OVERHEAD
\end{itemize}

Because LoRa communication is dependant on the number of symbols transmitted
instead of the number of bytes, the current implementation in TSCH is not
precise enough.

I changed the TSCH implementation to allow my own macro, and
I replaced it by the equation~\ref{eq:tpacket} for precise measurement
of the time on air.

\subsection{Radio delay}

Radio delays are hardware platform-dependent values. 
They get accessed from the radio driver.

TSCH uses these three values

\begin{itemize}
  \item RADIO\_CONST\_DELAY\_BEFORE\_TX
  \item RADIO\_CONST\_DELAY\_BEFORE\_RX
  \item RADIO\_CONST\_DELAY\_BEFORE\_DETECT
\end{itemize}

They should in theory be constant but since the communication delay depends
on the transmission length with the RN2483 module, I made them variable.

% TODO oscilloscope output picture

\subsubsection{Transmission delay}

It represents the time for the module to get messages on the air. 
This delay is made of three parts

\begin{enumerate}
  \item UART message transmission to the module.
  \item Module message treatment (duration between the ends of $1.$ and the start of $3.$).
  \item Module sending back an acknowledgement.
\end{enumerate}

The program knows the message length because
\lstinline{NETSTACK_RADIO.prepare()} is executed before getting this parameter.
The acknowledgement length is constant. 
I can then calculate parameter $1.$ and $3.$ with equation~\ref{eq:baudrate}.

\begin{equation}
  \label{eq:baudrate}
  UART(x) = \frac{x . (bit_{start} + bits_{data} + bit_{stop})}{baudrate}
\end{equation}

The second parameter is unknown, and the datasheet does not give any meaningful
information about the timing of the module.

I did measurement\footnote{The poor resolution of my oscilloscope introduced
some accuracy errors in the longer measures} of the time between message
transmission and acknowledgement with an oscilloscope to try to find a
correlation between the number of bytes transmitted and the treatment length.

\begin{figure}[H]
  \centering

  \begin{tikzpicture}

  \begin{groupplot}[group style={group size=1 by 2,
      horizontal sep=0pt,
      vertical sep=1cm},
      height=6cm,width=6cm,
  ]
  \nextgroupplot[
    width=0.8\textwidth,
    height=0.6\textwidth,
    axis x line=bottom,
    ymin=3000,
    ymax=24000,
    ylabel={$time_{\mu s}$},
    ylabel near ticks,
    yticklabel style={/pgf/number format/1000 sep=},
    axis y line=left,
    xmin=0,
    xmax=128,
    xlabel={bytes},
    xlabel near ticks
  ]
    \addplot[color=red,mark=x] coordinates {
      (1,3080)
      (4,3560)
      (8,4200)
      (21,6400)
      (32,8280)
      (58,12600)
      (64,13680)
      (86,17360)
      (124,23800)
    };
    \addlegendentry{Measurements}
    \addplot[color=blue] coordinates {
      (1,3021)
      (4,3528)
      (8,4204)
      (16,5556)
      (32,8260)
      (64,13668)
      (110,21442)
    };
    \addlegendentry{Predictions}

  \nextgroupplot[
    ycomb,
    width=0.8\textwidth,
    height=0.25\textwidth,
    axis lines=middle,
    ymin=-100,
    ymax=100,
    ylabel={$time_{\mu s}$},
    ylabel near ticks,
    yticklabel style={/pgf/number format/1000 sep=},
    xmin=0,
    xmax=128,
    xticklabels=\empty,
  ]
    \addplot[color=blue, mark=x] coordinates {
      (1,-59)
      (4,-32)
      (8,4)
      (16,6)
      (32,-20)
      (64,-12)
      (110,12)
    };

  \end{groupplot}

  \end{tikzpicture}

  \caption{Message treatment delay measurements and variation with the prediction\label{fig:transmissiondelay}}
\end{figure}

There is a clear linear relationship between the number of bytes transmitted and
the message treatment time.
Based on these measurements the best matching function is the following.

\begin{equation}
  \label{eq:transmissioncompute}
  T_{TX}(x) = 2852 + 169x \ \ \ \ (\mu s)
\end{equation}

The parameter returns the total transmission delay with the following
equation~\ref{eq:transmissiondelay}.

\begin{gather}
  \label{eq:transmissiondelay}
  msg_{length}(x) = x * 2 + length("radio~tx~\backslash r \backslash n") \\
  Delay_{TX}(x) = T_{TX}(x) + UART(msg_{length}(x)) + UART(length("ok \backslash r\backslash n"))
\end{gather}

The spreading factor does not influence the transmission delay.

The precision of this parameter is essential for synchronized communication
with TSCH. It will indicate to TSCH how to conduct its radio transmission
precisely at the end of \lstinline{TS_TX_OFFSET}.

\subsubsection{Reception delay}

This parameter is hard to measure with the RN2483.

It consists of the two following steps.

\begin{enumerate}
  \item Waking up the radio.
  \item Start listening to incoming messages.
\end{enumerate}

Because in my implementation the radio is always on (as I will explain in
Section~\ref{section:energyconsumption}) there is no real reception
delay.
This variable is then not used but should be taken into account in other
implementations.

\subsubsection{Detection delay\label{section:detectiondelay}}

% TODO Detection does not really represent that. It the delay between the start
% of the transmission and the acknowledgement by the platform since we can't
% really know when the communication start this value will be used out of
% context.
% Because RN2483 miss a way to detect transmission we are using variable in
% TSCH the wrong way.

Represent the time for the platform to detect the reception of a new message
from the moment the communication is finished.
This delay is made of two parts we can calculate when we know the message
length.

\begin{enumerate}
  \item Module message computation
  \item UART message transmission from the module to the platform
\end{enumerate}

I also measured the delay between the end of communication and the start of the
message transmission to the platform with an oscilloscope.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}

  \begin{groupplot}[group style={group size=1 by 2,
      horizontal sep=0pt,
      vertical sep=1cm},
      height=6cm,width=6cm,
  ]
  \nextgroupplot[
    width=0.8\textwidth,
    height=0.6\textwidth,
    axis x line=bottom,
    ymin=0,
    ymax=55000,
    ylabel={$time_{\mu s}$},
    ylabel near ticks,
    yticklabel style={/pgf/number format/1000 sep=},
    axis y line=left,
    xmin=0,
    xmax=128,
    xlabel={bytes},
    xlabel near ticks
  ]
    \addplot[color=red,mark=x] coordinates {
      (1,820)
      (2,1420)
      (3,1940)
      (4,2350)
      (8,4240)
      (16,8160)
      (32,15600)
      (64,31100)
      (110,53200)
    };
    \addlegendentry{Measurements}
    \addplot[color=blue] coordinates {
      (1,898)
      (4,2332)
      (8,4244)
      (16,8068)
      (32,15716)
      (64,31012)
      (110,53000)
    };
    \addlegendentry{Predictions}

  \nextgroupplot[
    ycomb,
    width=0.8\textwidth,
    height=0.25\textwidth,
    axis lines=middle,
    ymin=-200,
    ymax=200,
    ylabel={$time_{\mu s}$},
    ylabel near ticks,
    yticklabel style={/pgf/number format/1000 sep=},
    xmin=0,
    xmax=128,
    xticklabels=\empty,
  ]
    \addplot[color=blue, mark=x] coordinates {
      (1,68)
      (4,-18)
      (8,4)
      (16,-92)
      (32,116)
      (64,-88)
      (110,-200)
    };

  \end{groupplot}

  \end{tikzpicture}
  \caption{Reception delay measurements and variation with the prediction\label{fig:transmissiondelay}}
\end{figure}

The best matching function I found, used the number of symbols transmitted as
the parameter.

\begin{equation}
  \label{eq:detectcomp}
  T_{detect}(x) = 408x + 49 . N_{sym}(x) \ \ \ (\mu s)
\end{equation}

The total detection delay is calculated with the following formula.

\begin{gather}
  msg_{length}(x) = x * 2 + length("radio~rx~~\backslash r \backslash n") \\
  \label{eq:detectdelay}
  Delay_{detect}(x) = T_{detect}(x) + UART(msg_{length}(x))
\end{gather}

\subsection{Packet Timestamp}

As we saw in Figure~\ref{fig:sync} each time slot uses the same offset before 
starting the transmission.
Knowing the packet timestamp precisely allows the receiving mote to learn the
drift from the transmitter. 
The clock is adjusted when receiving a packet from a time source.
% Contiki takes the packet timestamps at the moment the transmission starts.

There is no way for the RN2483 module to know when the reception started but
the timestamp is saved when the packet is fully received by the platform.
On packet reception, I calculate the communication start time with the 
\emph{detection delay} covered in section~\ref{section:detectiondelay} and
equation~\ref{eq:detectdelay}, as well as the transmission time of
section~\ref{section:transmissiontime} and equation~\ref{eq:tpacket}.

The implementation is available in appendix~\ref{code:timestampimpl}.

% \subsection{Mitigating the drift}

% The transmitter can know in advance the moment the receiver will fully
% receive the message. In the previous implementation of TSCH the transmitter
% slot operation used to wait a constant time between transmissions. I modified
% this to include the detection delay at the transmitter side and the receiver
% will wait a constant time at reception instead.

% This will mitigate the effect of drifting timeslots, big messages are increasing
% the detection time that could lead to miss the time frame for sending the
% acknowledgement.

\section{Drift issues}

During the adaptation of the TSCH protocol for the RN2483, I stumbled upon huge
clock drifts that made me unable to run a reliable network using TSCH.

After several improvement and research, I concluded that the RN2483
module we were using and the assumption I made in the previous section about it
computation time were still too imprecise to run with the Contiki TSCH
implementation out of the box.

The functions \ref{eq:transmissiondelay} and \ref{eq:detectcomp} can
create imprecisions of multiple ms.
The original implementation tried to statistically correct the internal clock
drift of the motes with the function
\lstinline{tsch_timesync_adaptive_compensate}.
The function learned from the nodes drift from the time source to predict the
difference.

Figure~\ref{fig:driftmeasurement} shows how
\lstinline{tsch_timesync_adaptive_compensate} introduces a lot more drift on the
receiver time slot on a network of two nodes running for 10 minutes.
The lower overall drift explains why I stopped using this function.
Re-using the adaptive compensation should be done with a module that can
provide an acknowledgement at packet reception.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \begin{axis}
      [
      width=\textwidth,
      height=0.5\textwidth,
      ytick={1,2},
      yticklabels={w/o, w},
      xlabel={$time_{ms}$},
      xlabel near ticks,
      ]
      \addplot+[
      boxplot prepared={
        median=0.25,
        upper quartile=0.40,
        lower quartile=-1.95,
        upper whisker=7.9,
        lower whisker=-8.9
      },
      ] coordinates {};
      \addplot+[
      boxplot prepared={
        median=3.33,
        upper quartile=6.500,
        lower quartile=-4.100,
        upper whisker=13.333,
        lower whisker=-16.666
      },
      ] coordinates {};
    \end{axis}
  \end{tikzpicture}
  \caption{Drift measurement with and without \lstinline{tsch_timesync_adaptive_compensate}\label{fig:driftmeasurement}}
\end{figure}

\section{Testing\label{section:tschtesting}}

\subsection{Channel Jamming}

The example is inspired by the same test conducted in~\cite{tschoverlora}.
The goal is to demonstrate the resilience of transmitting messages with LoRa and
TSCH over a busy channel.
To conduct this test, I used two motes running a TSCH network and the third one
as a jammer like in Figure~\ref{fig:jammer}.

\input{thesis.tex/chapters/tsch/fig/jamming.tex}

One mote from the TSCH network will send UDP messages to the coordinator
every 30 seconds.
Meanwhile, the third mote constantly sends messages on the same channel to
simulate a busy channel of the network.
The test the protocol can deal with interference by retransmitting 
the message on a different channel.

\paragraph{}

I sent 50 packets to the coordinator in the course of my test and all of them
managed to reach the destination.
Figure~\ref{fig:retransmission} shows the amount of retransmission for each
packet transmitted during the test.
This test could be enhanced by measuring the transmission time of the packet
with and without the channel jammed but I couldn't get my hand on a digital
analyzer to measure every transmission.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}

  \begin{groupplot}[group style={group size=1 by 2,
      horizontal sep=0pt,
      vertical sep=1cm},
      height=6cm,width=6cm,
  ]
  \nextgroupplot[
    ycomb,
    width=0.8\textwidth,
    height=0.25\textwidth,
    axis lines=middle,
    ymin=0,
    ymax=4,
    ylabel={$Retry_{number}$},
    ylabel near ticks,
    yticklabel style={/pgf/number format/1000 sep=},
    xmin=0,
    xmax=50,
    xlabel={$Transmission_{number}$},
    xlabel near ticks,
  ]
    \addplot[color=blue, mark=x] coordinates {
      (1,1)
      (2,2)
      (3,0)
      (4,0)
      (5,0)
      (6,1)
      (7,0)
      (8,0)
      (9,1)
      (10,0)
      (11,1)
      (12,1)
      (13,2)
      (14,0)
      (15,2)
      (16,0)
      (17,1)
      (18,1)
      (19,1)
      (20,0)
      (21,4)
      (22,0)
      (23,0)
      (24,1)
      (25,0)
      (26,0)
      (27,2)
      (28,1)
      (29,0)
      (30,0)
      (31,1)
      (32,1)
      (33,0)
      (34,0)
      (35,0)
      (36,1)
      (37,2)
      (38,0)
      (39,0)
      (40,0)
      (41,1)
      (42,1)
      (43,0)
      (44,0)
      (45,3)
      (46,1)
      (47,0)
      (48,0)
      (49,1)
      (50,1)
    };
  \end{groupplot}
  \end{tikzpicture}
  \caption{Number of retransmission depending on the packet send during the test\label{fig:retransmission}}
\end{figure}

\subsection{RPL Custom Schedule}

For this example, I will create a custom schedule and test if the application can
work on top of the TSCH and LoRa network.
For this purpose, I will run a UDP client and server on each node and will try
to send a message between two nodes to see the packet get routed correctly with
RPL and the multi-hop topology.

\paragraph{}

I received a multitude of boards from the ETRO Lab, to run my
implementation on, with the following MAC addresses.

\begin{enumerate}
  \item $:2f2a$
  \item $:2f09$
  \item $:2dac$
  \item $:2dbc$
\end{enumerate}

To run a custom schedule we must first disable the default 6TiSCH minimal schedule.

\begin{lstlisting}
#define TSCH_SCHEDULE_CONF_WITH_6TISCH_MINIMAL 0
\end{lstlisting}

Custom schedules in Contiki can be done from anywhere with the help of the
function \lstinline{tsch_schedule_add_link}, the code for the custom schedule
is available in the appendix (see Appendix~\ref{code:customsched}).
The schedule I made is schematized in Figure~\ref{fig:customsched}, the $:2f2a$ 
node is the network coordinator and it uses a single channel.

\input{thesis.tex/chapters/tsch/fig/schedule.tex}

I used the NETSTACK in Figure~\ref{fig:tschstack} to run this example.

\input{thesis.tex/chapters/tsch/fig/stack.tex}

My goal to prove the routing and the multi-hop functionality are working
correctly is to send a UDP message from $:2f09$ to $:2dbc$.
The message coming from $:2f09$ will have to go through $:2dac$ and $:2f2a$ to
reach $:2dbc$ (see Fig~\ref{fig:route}).

\input{thesis.tex/chapters/tsch/fig/route.tex}

% TODO output the 'route' command of the :2f09 command to demonstrate it don't
% have knowledge of the rest of the network.

% TODO talk about network formation time to join it. Graph ?

The $:2f2a$ node is set as the network coordinator, it will be the first node to be
run in the network and the other nodes will join him.
To send a message to another node from $:2f09$ we must first wait it 
knows the root node to send the packet to.
We can check this with the command \lstinline{routes}.

\begin{lstlisting}[language=none]
#0012.4b00.14d5.2f09> routes
Default route:
-- fe80::212:4b00:14d5:2f2a (lifetime: infinite)
\end{lstlisting}

The root node should also reach the end node.

\begin{lstlisting}[language=none]
#0012.4b00.14d5.2f2a> ip-nbr
Node IPv6 neighbors:
-- fe80::212:4b00:14d5:2dbc, router 0, state Reachable 
-- fe80::212:4b00:14d5:2dac, router 0, state Reachable 
-- fe80::212:4b00:14d5:2f09, router 0, state Reachable 
\end{lstlisting}

To send a 'ping' message to another node, I made a custom shell 
command \lstinline{msg_to} that sends a UDP message to the IPv6 address 
passed in argument.
Each node of the network is running a UDP server on port 8765.

\begin{lstlisting}[language=none]
#0012.4b00.14d5.2f09> msg_to 0012.4b00.14d5.2dbc
Sending message to fd00::212:4b00:14d5:2dbc
[INFO:TSCH] send packet to 0012.4b00.14d5.2f2a with seqno 46, queue 7 8, len 21 51
[INFO:TSCH] {asn 00.00001eca link  0   7   0  0  0 ch  1} uc-1-0 tx LL-2f09->LL-2f2a, len  51, seq  46, st 2  1
\end{lstlisting}

The \lstinline{:2f2a} node receives the following message on the reception of the
request.

\begin{lstlisting}[language=none]
[INFO:TSCH] received from 0012.4b00.14d5.2f2a with seqno 155
[INFO:MAIN] Received request 'ping' from fd00::212:4b00:14d5:2f09
\end{lstlisting}

This shows my network can send and receive UDP messages using RPL.

\subsection{Orchestra}

Similarly to the previous example, in this section, I use Orchestra autonomous
scheduler on top of my TSCH network.
Transmitting a message between two nodes by the mean of a hop would again show
the TSCH implementation for LoRa is compatible with the stacks previously used.

\paragraph{}

I ran a three nodes network made of the following addresses.

\begin{enumerate}
  \item $:2dac$ (coordinator)
  \item $:2f2a$
  \item $:2dbc$
\end{enumerate}

Orchestra is simply enabled on Contiki by adding the next line in the project
\lstinline{Makefile}.

\begin{lstlisting}
MODULES += \$(CONTIKI_NG_SERVICES_DIR)/orchestra
\end{lstlisting}

The network formation and route building take more time to be created than with
the RPL custom schedule.
But after giving the network some time to organize the structure in
Figure~\ref{fig:orchestra} is in use.

% \begin{lstlisting}
% TSCH schedule:
% -- Slotframe: handle 0, size 397, links:
% ---- Options 01, type 2, timeslot 42, channel offset 0, address ffff.ffff.ffff.ffff
% ---- Options 02, type 2, timeslot 188, channel offset 0, address ffff.ffff.ffff.ffff
% -- Slotframe: handle 1, size 17, links:
% ---- Options 05, type 0, timeslot 0, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 1, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 2, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 3, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 4, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 5, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 6, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 7, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 07, type 0, timeslot 8, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 9, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 10, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 11, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 12, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 13, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 14, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 15, channel offset 44, address ffff.ffff.ffff.ffff
% ---- Options 05, type 0, timeslot 16, channel offset 44, address ffff.ffff.ffff.ffff
% -- Slotframe: handle 2, size 31, links:
% ---- Options 07, type 0, timeslot 0, channel offset 1, address ffff.ffff.ffff.ffff
% \end{lstlisting}

\input{thesis.tex/chapters/tsch/fig/orchestra.tex}

The node $:2f2a$ has no route to $:2dac$, I will send a message to between
those two nodes to prove the multihop function is correctly working.
The coordinator has full knowledge of all the routes in the network.

\begin{lstlisting}
Routing links (3 in total):
-- fd00::212:4b00:14d5:2dac  (DODAG root) (lifetime: infinite)
-- fd00::212:4b00:14d5:2dbc  to fd00::212:4b00:14d5:2dac
-- fd00::212:4b00:14d5:2f2a  to fd00::212:4b00:14d5:2dbc
\end{lstlisting}

Sending a UDP message to $:2dac$ worked seamlessly by passing by the
intermediate node $:2dbc$.

\section{Energy consumption\label{section:energyconsumption}}

Because of the missing feature of the RN2483 module, a real-world measurement of
the energy consumption is not relevant.
The module is wasting energy in two places.

\begin{itemize}
  \item The slow UART communication between the platform and the module. A max 
    payload transmission to the module takes $86 ms$.  That's $86 ms$ of wasted 
    energy where the radio is on receive mode.
  \item Because we can't receive feedback from the module when it detects a
    preamble each timeslot must wait for the maximum transmission time. This could
    be avoided.
\end{itemize}

Because I knew I would not be able to measure meaningful data from my
implementation, I did not take time to experiment with the sleep feature of the
module.
